name: Deploy to Lanna AI

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

# Ensure only one deployment runs at a time to prevent race conditions
concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  # Use github.repository as the image name (owner/repo)
  IMAGE_NAME: ${{ github.repository }}
  CONTAINER_NAME: "landingpage-app"
  PORT: "3030"

jobs:
  # Job 1: Build on Cloud (GitHub Runners)
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Lowercase Image Name
        run: echo "IMAGE_NAME=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata (tags, labels) for Docker
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=sha,format=long

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # Job 2: Deploy on Self-Hosted Server
  deploy:
    name: Deploy to Server
    needs: build
    runs-on: self-hosted
    timeout-minutes: 15

    steps:
      - name: Lowercase Image Name
        run: echo "IMAGE_NAME=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Login to GitHub Container Registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Pull Docker Image
        run: |
          echo "‚¨áÔ∏è Pulling latest image..."
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Stop & Remove Old Container
        run: |
          echo "Checking for existing container: ${{ env.CONTAINER_NAME }}"
          if [ "$(docker ps -aq -f name=${{ env.CONTAINER_NAME }})" ]; then
              echo "Existing container found. Stopping and removing..."
              docker stop ${{ env.CONTAINER_NAME }}
              docker rm ${{ env.CONTAINER_NAME }}
          else
              echo "No existing container found."
          fi

      - name: Run New Container
        run: |
          echo "üöÄ Starting new container..."
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            -p ${{ env.PORT }}:${{ env.PORT }} \
            --restart unless-stopped \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          echo "   Container started with ID: $(docker ps -q -f name=${{ env.CONTAINER_NAME }})"

      - name: Health Check
        id: health-check
        run: |
          echo "üè• Performing Health Check on port ${{ env.PORT }}..."
          
          # Retry loop (Wait up to 60 seconds)
          MAX_RETRIES=12
          SLEEP_SECONDS=5
          SUCCESS=false

          for ((i=1; i<=MAX_RETRIES; i++)); do
            echo "   Attempt $i/$MAX_RETRIES: Checking http://localhost:${{ env.PORT }}..."
            
            # Check if endpoint returns HTTP 200
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:${{ env.PORT }} | grep -q "200"; then
              echo "   ‚úÖ Health check passed! Application is running."
              SUCCESS=true
              break
            fi
            
            echo "   Container not ready yet. Waiting ${SLEEP_SECONDS}s..."
            sleep $SLEEP_SECONDS
          done

          if [ "$SUCCESS" = false ]; then
            echo "   ‚ùå Health check failed after $((MAX_RETRIES * SLEEP_SECONDS)) seconds."
            echo "   Logs from container:"
            docker logs --tail 50 ${{ env.CONTAINER_NAME }}
            exit 1
          fi

      - name: Cleanup
        if: always() # Run cleanup even if deployment fails
        run: |
          echo "üßπ Cleaning up dangling images..."
          docker image prune -f
          echo "   Cleanup complete."